// Generated by CoffeeScript 1.3.3
(function() {
  var Admittance, EventEmitter, util, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  EventEmitter = require("events").EventEmitter;

  util = require("util");

  Admittance = (function(_super) {
    var assignments, children, items, _this;

    __extends(Admittance, _super);

    _this = null;

    items = {};

    assignments = {};

    children = {};

    function Admittance(adaptor) {
      this.adaptor = adaptor;
      _this = this;
      this.adaptor.load(function(err, pItems, pAssignments, pChildren) {
        items = pItems;
        assignments = pAssignments;
        children = pChildren;
        return _this.emit("load");
      });
    }

    /*
            Adds an auth item to another auth item as a child
            This stored as an id reference.
            eg. 'parent' = ['child1', 'child2']
            An error event is triggered if either the item or the
            child being referenced do not exist
            @param {string} itemName
            @param {string} childName
    */


    Admittance.prototype.addItemChild = function(itemName, childName) {
      if (items[childName] && items[itemName]) {
        children[itemName] = children[itemName] || [];
        return children[itemName].push(childName);
      } else {

      }
    };

    /*
            Assigns a auth item (given by id) to a user (given by id)
            @param {string} itemName - name of auth item
            @param {string} userId   - id of user
            @param {string} bizRule  - expression
    */


    Admittance.prototype.assign = function(itemName, userId, bizRule, data) {
      var item;
      item = {
        itemName: itemName,
        userId: userId,
        bizRule: bizRule,
        data: data
      };
      assignments[userId] = assignments[userId] || {};
      return assignments[userId][itemName] = item;
    };

    /*
            Checks if a user (give by id) has the requested
            permission (specified by id)
            if the requested permission is in any of the 
            assigned auth item trees that have been assigned
            to the user, this method will return true
            @param {string} itemName - auth item
            @param {string} userId   - user id
            @param {array} params    - 
            @return {boolean}        - true if the user has the
            appropriate permissions
    */


    Admittance.prototype.checkAccess = function(itemName, userId, params) {
      var item, key, userAssignments, userItems;
      if (params == null) {
        params = [];
      }
      userAssignments = [];
      userItems = this.getAuthItems(null, userId);
      for (key in userItems) {
        if (!__hasProp.call(userItems, key)) continue;
        item = userItems[key];
        userAssignments.push(item.name);
      }
      return _.contains(userAssignments, itemName);
    };

    /*
            Clears all permissions. The save method must be called
            after calling clearAll if you want the wipe to be
            persisted. If you dont call save after clearAll, when you
            next load the application, permissions will be restored
            via the adaptor
    */


    Admittance.prototype.clearAll = function() {
      items = {};
      assignments = {};
      return children = {};
    };

    /*
            Clears all auth assignment. The save method must be called
            after calling clearAuthAssignments if you want the wipe to be
            persisted. If you dont call save after clearAuthAssignments,
            when you next load the application, permissions will be restored
            via the adaptor
    */


    Admittance.prototype.clearAuthAssignments = function() {
      return assignments = {};
    };

    /*
            Creates an auth item with a given name, type and description
            You may also specify a business rule expression and any
            data
            @param {string} name       - name for the auth item eg. admin
            @param {int}    type       - type int, either 0, 1, or 2
                0: operation, 1: task, 2: role
            @param {string} descrition - information about the auth item
            @param {string} bizRule    - expression to evaluate
            @param {string} data       -
    */


    Admittance.prototype.createAuthItem = function(name, type, description, bizRule, data) {
      var item;
      if (description == null) {
        description = "";
      }
      item = {
        name: name,
        type: type,
        description: description,
        bizRule: bizRule,
        data: data
      };
      return items[name] = item;
    };

    /*
            Evaluates and checks give business rule
    */


    Admittance.prototype.executeBizRule = function(bizRule, params, data) {};

    /*
            Corresponds to directly assigned auth items
            for a user. ie, child items not directly 
            assigned to a user will not be returned
            @param {string} itemName - name of auth item eg. admin
            @param {string} userId   - user id to return against
            @return {object} - assignment data in an object
    */


    Admittance.prototype.getAuthAssignment = function(itemName, userId) {
      if (assignments[userId] && assignments[userId][itemName]) {
        return assignments[userId][itemName];
      }
    };

    /*
            Returns directly assigned user auth items
            ie, implied auth assignments are not returned
            @param {string} userId - id of user
            @return {object} - object where each key is an
            assignment for the given user
    */


    Admittance.prototype.getAuthAssignments = function(userId) {
      return assignments[userId];
    };

    Admittance.prototype.getAuthItem = function(name) {
      return items[name];
    };

    Admittance.prototype.getAuthItems = function(type, userId) {
      var authItems, key, userItems, value;
      if (type == null) {
        type = null;
      }
      authItems = [];
      userItems = this.traverseItems(assignments[userId]);
      for (key in userItems) {
        if (!__hasProp.call(userItems, key)) continue;
        value = userItems[key];
        authItems.push(items[key]);
      }
      return authItems;
    };

    Admittance.prototype.hasItemChild = function(itemName, childName) {
      if (children[itemName] && _.contains(children[itemName], childName)) {
        return true;
      } else {
        return false;
      }
    };

    Admittance.prototype.isAssigned = function(itemName, userId) {
      if (assignments[userId] && assignments[userId][itemName]) {
        return true;
      } else {
        return false;
      }
    };

    Admittance.prototype.removeAuthItem = function(name) {
      if (items[name]) {
        return items[name] = null;
      }
    };

    Admittance.prototype.removeItemChild = function(itemName, childName) {
      if (children[itemName] && children[itemName][childName]) {
        return children[itemName][childName] = null;
      }
    };

    Admittance.prototype.revoke = function(itemName, userId) {
      if (assignments[userId] && assignments[userId][itemName]) {
        return assignments[userId][itemName] = null;
      }
    };

    Admittance.prototype.save = function(cb) {
      return this.adaptor.save(items, assignments, children, function() {
        _this.emit("save");
        return cb();
      });
    };

    /*
         Recursively traverse items into a flat array
         @param  {object} items - map of items
         @return {array}       - flattened array of all children
    */


    Admittance.prototype.traverseItems = function(assignedItems) {
      var collection, item, key, recurseResult;
      collection = {};
      for (key in assignedItems) {
        if (!__hasProp.call(assignedItems, key)) continue;
        item = assignedItems[key];
        collection[key] = item;
        if (children[key] && children[key].length > 0) {
          recurseResult = this.traverseItems(this.getItemChildren(key));
          collection = _.extend(collection, recurseResult);
        }
      }
      return collection;
    };

    Admittance.prototype.getItemChildren = function(itemName) {
      var childItemNames, childItems, key, name;
      childItemNames = children[itemName];
      childItems = {};
      for (key in childItemNames) {
        if (!__hasProp.call(childItemNames, key)) continue;
        name = childItemNames[key];
        childItems[name] = items[name];
      }
      return childItems;
    };

    return Admittance;

  })(EventEmitter);

  module.exports = Admittance;

}).call(this);
